\pagebreak
\section{enum-to-string tool overview}
This section describes a tool that is capable of generating \cppinline{std::string_view to_string(EnumType e)} functions for each enum declaration defined in a C++ program. The \cppinline{to_string} functions take an instance of the enum as argument and returns a string corresponding to the name of the enumerator.

An example of the outputs of running the tool can be seen in \cref{code:085tool:example_enum}. In the example, in part (1), the enum \cppinline{Animal} is declared with two enumerators: Dog and Cat. In part (2), the \cppinline{to_string} function that would be generated by the tool can be seen. Parts (3) and (4) show another enum declaration with another generated \cppinline{to_string} function.

\begin{listing}[H]
    \begin{cppcode}
// (1): Example enum declaration:
enum class Animal{
    Dog, // Dog is an example of an enumerator (aka. enum constant)
    Cat // Cat is another example of an enumerator
};


// (2): Function that the tool generates:
constexpr std::string_view to_string(Animal e){
    switch(e) {
        case Animal::Dog: return "Dog";
        case Animal::Cat: return "Cat";
    }
}

// (3): Another enum declaration:
enum Greetings {
    ... // enumerators for Greetings
};

// (4): The other enum declaration also gets a to_string function
constexpr std::string_view to_string(Greetings e){
    switch (e) {
        ... 
    }
}
    \end{cppcode}
    \caption{Example (1) declaring an enum in C++ and (2) the \cppinline{to_string} function that the tool generates. In (3) another enum was declared from which another \cppinline{to_string} function is generated (4).}
    \label{code:085tool:example_enum}
\end{listing}

\subsection{Difference from previous tools}

The tool differentiates itself from the previous examples by being a generative tool, meaning that it inserts source code into a file.
In contrast, the renaming tool and CStyle comparison tool were refactoring tools that would overwrite existing code lines.
While the difference may seem subtle, it can be more challenging to design generative tools, as there are stricter requirements related to analyzing if the generated code is syntactically correct when combined with the existing code base.\\
E.g., with the enum-to-string tool, it is necessary to determine if there already exists a function named \cppinline{to_string} in the same namespace that takes a single parameter of the enum type, since redefinition of functions is not allowed in C++.
In case such a function already exists, one needs to determine a strategy on how to handle the conflicts, e.g., by leaving the function untouched or overwriting it.
The act of determining whether such a function exists can be quite complex, as one must analyze the compilation unit for its existence.

Likewise, there are typically extra semantic considerations to be made when designing a generative tool. E.g., if \cppinline{std::string_view to_string(Animal e)} function exists in a namespace ``A'' and \cppinline{Animal} was declared in namespace ``B'', then it would be syntactically correct to add the \cppinline{to_string} function to namespace ``B''. The question of whether it semantically makes sense for these functions to coexist arises
\footnote{This must be determined on a case-by-case basis. E.g. it might make sense for two \cppinline{print(X)} functions to exist in separate namespaces. One that is part of the public API and one that is intended for debugging. However, it might not make sense for two \cppinline{release(X)} functions to exist in separate namespaces as this would indicate there are several ways of releasing the resources allocated in X. (And yet in other cases, it might make perfect sense for two \cppinline{release(X)} functions to exist.)}
and one needs to select a strategy for handling such scenarios.\\
Examples of such strategies could be to ignore the cases, warn the user about them, delete the non-generated version or overwrite the non-generated version.\\
It can be difficult to find and consider all the possible semantic strategies when developing a tool. For some problems, there could be infinite ways to generate the wanted behaviour, like there is when creating a program through a programming language. Some of the possibilities may be better than others but there is still a large design space that could be explored.
To demonstrate this, a list of scenarios where one might need to consider the behaviour of the enum-to-string tool can be seen below. The examples in the list increasingly become more abstract and difficult to implement.

\begin{itemize}
    \vspace{-0.75em}
    \item A \cppinline{to_string} function taking multiple arguments already exists.
    \item The enum is declared privately inside a class.
    \item The enum is declared inside an anonymous namespace.
    \item The enum is declared inside a namespace that by convention is intended to be ignored by users (e.g., \cppinline{detail}, \cppinline{implementation}, etc.).
    \item A function that implements the same behaviour as the generated \cppinline{to_string} function exists.
    \item A function that implements a similar behaviour as the generated \cppinline{to_string} function exists.
    \item A similarly named function exists that implements a similar behaviour as the generated \cppinline{to_string} function exists.
    \item ...
\end{itemize}

For the enum-to-string tool, it was decided to overwrite syntactically conflicting implementations of the \cppinline{to_string()} functions.
This has the benefit of allowing the user to change the enum and re-run the tool to see the updated changes. E.g., in \cref{code:085tool:example_enum} if a \cppinline{Animal::Horse} was added to the enum declaration, re-running the tool would update the corresponding \cppinline{std::string_view to_string(Animal e)} function.
However, it also has the downside of essentially reserving the \cppinline{to_string} name leaving the user unable to write their own versions of the function.\\
Furthermore, it was decided to also implement the semantic rule that if a \cppinline{to_string} function already exists in a different namespace, then the existing version must be overwritten. This was mainly decided as there are some interesting challenges to consider concerning recursively traversing the namespaces, which are described in \cref{subsec:085tool:enum_node_matching_sin}.

\subsection{Implementations}
The enum-to-string tool is more complex than the previously described tools as it consists of matching on multiple independent declarations of the source code, i.e., the enum declarations and the existing \cppinline{to_string} function declarations. The added complexity allows for a wider variety of design approaches, which was shown as part of the project, where three different implementations were considered and two were implemented.

The first approach could implement the tool in a single step, similarly to how it was done in \cref{sec:045tool:c_style_array}. Pseudocode for such a tool can be seen in \cref{code:085tool:pseudo_enum1}. The pseudocode iterates over all the enum declarations in the source code and determines if a \cppinline{to_string} already exists. Depending on the outcome, the function is either updated or generated.

\begin{listing}[H]
    \begin{pythoncode}
for enum_decl in source_files:
    to_string_inst := find(to_string(enum_decl))
    if to_string_inst:
        update to_string_inst
    else:
        generate to_string(enum_decl)
    \end{pythoncode}
    \caption{Pseudocode for the enum-to-string tool.}
    \label{code:085tool:pseudo_enum1}
\end{listing}

An alternative implementation of the tool can be seen in \cref{code:085tool:pseudo_enum2}, which follows a multi-step procedure. The first step consists of updating the existing \cppinline{to_string} functions and saving the relevant enum type in a collection (\textinline{parameters}). The second step consists of finding all the enum declarations and generating the \cppinline{to_string} functions that were not updated in step 1.

\begin{listing}[H]
    \begin{pythoncode}
parameters := []
for existing_enum_to_string in source_files:
    update existing_enum_to_string
    parameters.append(existing_enum_to_string.parameter)

for enum_decl in source_files:
    if not enum_decl in parameters:
        generate to_string(enum_decl)
    \end{pythoncode}
    \caption{Pseudocode for the enum-to-string tool.}
    \label{code:085tool:pseudo_enum2}
\end{listing}

A third way of implementing the tool can be seen in \cref{code:085tool:pseudo_enum3}, which is also a multi-step procedure. The first step consists of identifying the existing \cppinline{to_string} functions. The second step consists of finding all the enum declarations. If the declaration already has a \cppinline{to_string} function then it is updated. Otherwise, it is generated.

The main difference between the second and the third implementation is regarding semantics. It might be simpler to divide the tool into two distinct phases consisting of a data collection phase and a post-processing phase, where the post-processing performs the actual logic of the tool. This appears to be a common division of responsibilities and is among others used in the a helper library that was written by Bloomberg \cite{ClangmetatoolFrameworkReusing2023}.

\begin{listing}[H]
    \begin{pythoncode}
parameters := []
for existing_enum_to_string in source_files:
    parameters.append(existing_enum_to_string)

for enum_decl in source_files:
    if enum_decl in parameters:
        update parameters[enum_decl]
    else:
        generate to_string(enum_decl)
    \end{pythoncode}
    \caption{Pseudocode for the enum-to-string tool.}
    \label{code:085tool:pseudo_enum3}
\end{listing}

% Maybe todo: I am not entirely happy with the paragraph below. I don't feel like I am getting my point across
The two designs from \cref{code:085tool:pseudo_enum2} and \cref{code:085tool:pseudo_enum3} have the benefit of being more modular than the one in \ref{code:085tool:pseudo_enum1} since they implement the tool behaviour in multiple steps.
Each step in the designs can essentially be considered independent tools that are chained together. This makes it easier to reuse the tools in other projects and makes it easier to test during development. For instance in \cref{code:085tool:pseudo_enum2}, the first for-loop can be considered a tool that identifies existing enum-to-string functions, logs them and updates them, and the second for-loop can be considered a tool that generates enum-to-string functions if they are not in the log.

During the project, the tool was implemented with the designss seen in \cref{code:085tool:pseudo_enum1} and \cref{code:085tool:pseudo_enum2}. The design from \cref{code:085tool:pseudo_enum3} was considered but was not implemented.

The following sections describe the two ``enum-to-string'' tools that were implemented.
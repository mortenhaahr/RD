\section{Enum-to-string -- single-step}
The following section describes the enum-to-string tool where the entire tool is implemented as a single \cppinline{ClangTool}.

\subsection{Command line parsing}
Most of the command line parsing was implemented as described in \cref{sec:085tool:example:simple_rename}. However, the behaviour was extended with two new options; ``in\_place'' and ``debug \_info''.
The ``in\_place'' option allows the user to specify whether the changes should be printed to the terminal or saved directly to the file.
The ``debug\_info'' option makes the tool print extra debug information to the console during execution.

The additional options were introduced as booleans options through the LLVM command line API, as seen in \cref{code:085tool:sin_cl_options}. It is simple to add command line options as one simply needs to specify a description and add it to the \cppinline{OptionCategory} -- which is \cppinline{MyToolCategory} in this case.

\begin{listing}[H]
    \begin{cppcode}
static llvm::cl::opt<bool> Inplace(
    "in_place",
    llvm::cl::desc("Inplace edit <file>s, if specified. If not specified the "
                   "generated code will be printed to cout."),
    llvm::cl::cat(MyToolCategory));
static llvm::cl::opt<bool> DebugMsgs(
    "debug_info", llvm::cl::desc("Print debug information to cout."),
    llvm::cl::cat(MyToolCategory));
    \end{cppcode}
    \caption{Implementation of the newly introduced command line options.}
    \label{code:085tool:sin_cl_options}
\end{listing}

The options can then be used as normal booleans throughout the implementation, as seen in \cref{code:085tool:sin_cl_in_place}.

\begin{listing}[H]
    \begin{cppcode}
if (!Inplace) {
    llvm::outs() << new_code.get();
}
    \end{cppcode}
    \caption{Using the \cppinline{Inplace} command line option to print the changes to the command line if \textinline{--in_place} was not specified when running the tool.}
    \label{code:085tool:sin_cl_in_place}
\end{listing}

The addition of ``in\_place'' option is in particular useful for the future development of tools, as it allows for easier system testing. It does so because test cases can be run on small and very specific virtual files instead of an existing code base.
Similar tests can be seen throughout the tools in the LLVM repository.

\subsection{AST node matching}\label{subsec:085tool:enum_node_matching_sin}

The AST node matching was by far the most challenging part of developing this tool as one needs to write a matcher that implements the following logic for each enum declaration:

\vspace*{-0.75em}
\begin{enumerate}
    \item Find and bind enum declaration
    \item Find the outermost namespace
    \item Recursively traverse the namespace to potentially find a matching \cppinline{to_string} function
\end{enumerate}

The behaviour described above is quite complex compared to the previous tools and required the implementation of recursive matchers, which the built-in matchers do not support. \\
The custom matchers will be described in the steps below.

\subsubsection*{Finding enum declarations}
A matcher for finding the enum declarations can be seen in \cref{code:085tool:sin_enum_finder} with the parts related to finding the \cppinline{to_string} functions left out.
The matcher is fairly straightforward except for lines 4 and 5. These are discussed below the listing.

\begin{listing}[H]
    \begin{cppcode}
auto enumFinder = enumDecl(
        isExpansionInMainFile(),
        has(enumConstantDecl(hasDeclContext(enumDecl().bind("enumDecl")))),
        matchers::is_named(),
        optionally(
            // Find matching enum_to_string
        ));
    \end{cppcode}
    \caption{Matcher for finding enum declarations.}
    \label{code:085tool:sin_enum_finder}
\end{listing}

The intention of line 3 in \cref{code:085tool:sin_enum_finder} is simply to bind the enum declaration, similarly to how it was done in the previous tools.
However, the implementation is different from the other tools, since the binding is used by the inner \cppinline{to_string} function matcher.
I.e., if the implementation was written as \cppinline{enumDecl(optionally(/*find to_string*/)).bind("enumDecl)}, the ``enumDecl'' binding would not be accessible to the ``to\_string'' matcher, as the outer binding only happens after all the inner matchers are evaluated.
Therefore, it was necessary to make the binding earlier, and line 3 is a way of achieving this.\\
The behaviour of the line is to find an enum declaration with an enum constant declaration\footnote{
    Note that this also filters out empty enum declarations which are uninteresting in terms of having a \cppinline{to_string} function.
} and then backtrack from the enum constant declaration in order to bind the original enum declaration. This logic allows the enum declaration to be bound before running the ``to\_string'' matcher.

Line 4 in \cref{code:085tool:sin_enum_finder} fixes a bug that was found when running the tool on an external project, i.e., the JSON \cite{Lohmann22}.
Before this line was introduced, the tool was unable to handle unnamed enums
\footnote{
    Unnamed enums were mainly used in C++ before \cppinline{constexpr} was introduced, for defining compile-time evaluated constants for metaprogramming usages.
}, which would throw an unhandled exception.\\
In the AST, an \cppinline{EnumDecl} inherits from a \cppinline{NamedDecl}, which contains the \cppinline{IdentifierInfo} related to the node.
An unnamed enum can be interpreted as a \cppinline{NamedDecl} with no \cppinline{IdentifierInfo} since it does not have a name.
The matcher can therefore be written as \cref{code:085tool:sin_is_named}, where the \cppinline{IdentifierInfo*} is implicitly converted to a boolean, returning false in it is a nullptr.

\begin{listing}[H]
    \begin{cppcode}
AST_MATCHER(NamedDecl, is_named) {
	return Node.getIdentifier(); // nullptr if no name
}
    \end{cppcode}
    \caption{Custom matcher for determining if a \cppinline{NamedDecl} has been given a name.}
    \label{code:085tool:sin_is_named}
\end{listing}

\subsubsection*{Finding the outermost namespace}
In order to potentially find the \cppinline{to_string} method matching the \cppinline{EnumDecl}, one must consider that the function might be placed inside a different namespace.
For that reason, it is necessary to consider all the namespaces inside the compilation unit when searching.
The implementation for such a matcher is somewhat similar to the implementation of the built-in \cppinline{hasDeclContext} that was used in \cref{code:085tool:sin_enum_finder}. 
The behaviour of \cppinline{hasDeclContext} is to return false, if the declaration does not have a \cppinline{DeclContext}\footnote{
    An example of a case of a \cppinline{Decl} that does not have \cppinline{DeclContext} is the outermost \cppinline{TranslationUnitDecl}.
}, otherwise return the result of evaluating the \cppinline{InnerMatcher} on the context casted to a \cppinline{Decl}.\\
The behaviour for the recursive version\footnote{Note that while the implementation seen in \cref{code:085tool:sin_rec_decl} has been transformed to its iterative version, the methodology can be considered recursively traversing the AST.} 
(\cppinline{has_rec_decl_context}) is similar, but instead of evaluating the inner matcher in the immediate parent context, it is evaluated in the outermost context. The implementation can be seen in \cref{code:085tool:sin_rec_decl}.

\begin{listing}[H]
    \begin{cppcode}
AST_MATCHER_P(Decl, has_rec_decl_context, Matcher<Decl>, InnerMatcher) {
	auto cur_ctx = Node.getDeclContext();
	if (!cur_ctx) {
		return false;
	}
	const DeclContext *nxt_ctx = nullptr;
	while (true) {
		nxt_ctx = cur_ctx->getParent();
		if (!nxt_ctx) {
			return InnerMatcher.matches(*Decl::castFromDeclContext(cur_ctx), Finder, Builder);
		}
		cur_ctx = nxt_ctx;
	}
}
    \end{cppcode}
    \caption{Custom matcher for finding the outermost context of an AST node.}
    \label{code:085tool:sin_rec_decl}
\end{listing}

\subsubsection*{Find matching ``to\_string''}
The remaining part of the \cppinline{enumFinder} matcher that was seen in \cref{code:085tool:sin_enum_finder} is to potentially identify the \cppinline{to_string} functions. The implementation can be seen in \cref{code:085tool:has_enum_to_string} with a description below the listing.

\begin{listing}[H]
    \begin{cppcode}
auto enumFinder = enumDecl(
  /* The rest of enumFinder...*/
  optionally(
    matchers::has_rec_decl_context(hasDescendant(
      functionDecl(
        hasName("to_string"),
        parameterCountIs(1),
        hasParameter(0,
          parmVarDecl(hasType(
            elaboratedType(namesType(
              hasDeclaration(
                equalsBoundNode("enumDecl")))))
          ).bind("parmVar"))
      ).bind("toString")))));
    \end{cppcode}
    \caption{The part of the \cppinline{enumFinder} matcher that was left out of \cref{code:085tool:sin_enum_finder}. It is responsible of optionally finding a \cppinline{to_string} function matching the ``enumDecl''.}
    \label{code:085tool:has_enum_to_string}
\end{listing}


The \cppinline{optionally} matcher indicates that the inner matcher is optional. \cppinline{has_rec_decl_context} is then used to traverse to the outermost context.
Curiously enough, unlike \cppinline{hasDeclContext}, the \cppinline{hasDescendant} function recursively matches on the descendants. This means that it can be utilized to recursively match the \cppinline{functionDecl}s in the context.
There are a couple of restrictions placed on the \cppinline{functionDecl} in order to be matched. It has to have the correct name and only a single parameter. The parameter also has to be identical to the previously bound ``enumDecl'' node.
The equality between the bound node and the parameter type is expressed through a series of matchers. As it is the type of the parameter which is interesting, the \cppinline{hasType} matcher is used. As the enum type may have a namespace qualifier, the inner matcher must take that into account and that is done through the \cppinline{elaboratedType}\footnote{
    An \cppinline{elaboratedType} refers to a type that potentially has a qualifier ahead of it.
} matcher.
The type has to be extracted from the \cppinline{elaboratedType} and that is done through the \cppinline{namesType} matcher.
The ``enumDecl'' tag, which was bound earlier, refers to a \cppinline{Decl} instead of a \cppinline{Type}, so \cppinline{hasDeclaration} is used to refer to the underlying \cppinline{Decl} stored in the \cppinline{elaboratedType}. The last step is to compare the \cppinline{Decl} to the bound ``enumDecl'' node.

The combined matcher satisfying the steps defined at the start of \cref{subsec:085tool:enum_node_matching_sin} has now been completed.
It should be clear to the reader that writing a single matcher that matches all the necessary nodes of the enum-to-string tool was no trivial achievement.

\subsubsection*{Finding the namespace in code}
When developing the single-step enum-to-string tool, the initial solution also contained a potential binding of the namespace of the \cppinline{parmVarDecl}, as it was thought to be needed during node data processing.
Later during the ``node data processing'' step, this approach turned out to be unnecessarily complex compared to retrieving the namespace directly through the \cppinline{SourceLocation}s.
However, the resulting matcher turned out to be interesting and will be discussed in the following.

Binding the namespace of the \cppinline{parmVarDecl} was challenging, as it, similarly to \cppinline{has_rec_decl_context}, required recursively\footnote{
    Once again, the implementation has been transformed into its iterative version.
}
traversing the AST until arriving at the outermost namespace qualifier of the \cppinline{parmVarDecl}.
Inspiration was found in the implementation of \cppinline{specifiesNamespace} which only considers the immediate namespace of the node.

The implementation of the matcher can be seen in \cref{code:085tool:rec_specifies_namespace}. Initially, it is verified that the node can be cast to a \cppinline{NamespaceDecl}.
The function \cppinline{getPrefix()} can be used to check if there is a \cppinline{NestedNameSpecifier} prefixing the current node.
The function \cppinline{getAsNamespace} can be used to convert the \cppinline{NestedNameSpecifier} to its underlying \cppinline{NamespaceDecl}.
Finally, the \cppinline{InnerMatcher} is run on the outermost \cppinline{NamespaceDecl} of the \cppinline{ParmVarDecl}.

\begin{listing}[H]
    \begin{cppcode}
AST_MATCHER_P(NestedNameSpecifier, rec_specifies_namespace, Matcher<NamespaceDecl>, InnerMatcher) {
	auto ns = Node.getAsNamespace();
	if (!ns) {
		return false;
	}
	auto prefix = Node.getPrefix();
	while (prefix && prefix->getPrefix()) {
		ns = prefix->getAsNamespace();
		prefix = prefix->getPrefix();
	}
	return InnerMatcher.matches(*ns, Finder, Builder);
}
    \end{cppcode}
    \caption{Implementation of the \cppinline{rec_specifies_namespace} custom matcher.}
    \label{code:085tool:rec_specifies_namespace}
\end{listing}

\subsection{Node data processing}
The logic for the node data processing step of the enum-to-string tool can be seen in \cref{code:085tool:enum_rule}.
The aforementioned \cppinline{enumFinder} is used as the \textit{matcher} and the \textit{edits} is a single \cppinline{changeTo} expression.
Inside \cppinline{changeTo} the \cppinline{RangeSelector} is determined dynamically for each match, depending on whether ``toString'' was bound. If it is bound then the \cppinline{SourceLocation} of the ``toString'' node is used, otherwise, the \cppinline{SourceLocation} right after the ``enumDecl'' node is used.
The edit is performed as seen in lines 5 to 10. The interesting parts are \cppinline{print_correct_name} and \cppinline{NodeOps::case_enum_to_string}, which will be discussed below.

\begin{listing}[H]
    \begin{cppcode}
auto enumRule = makeRule(
    enumFinder,
    changeTo(
        ifBound("toString", node("toString"), after(node("enumDecl"))),
        cat("\n\nconstexpr std::string_view to_string(",
            print_correct_name,
            " e){\n\tswitch(e) {\n",
            run(case_enum_to_string(print_correct_name, "enumDecl")),
            "\t}\n}")
    ));
    \end{cppcode}
    \caption{Implementation of the \cppinline{enumRule} that is responsible for node data processing. The \cppinline{RewriteRule} also adds the necessary headers, which have been left out of the listing to simplify.}
    \label{code:085tool:enum_rule}
\end{listing}

\subsubsection*{Printing the correct name}
In order to generate the \cppinline{to_string} function, the correct notation for referring to the parameter must be used. E.g., if the enum declaration ``Animals'' is in the namespace ``ns'' and the \cppinline{to_string} function is written outside the namespace, then the declaration must be \cppinline{to_string(ns::Animals e)}.
This is the behaviour that the callable \cppinline{print_correct_name} implements.
If the ``toString'' node is bound then the notation from the existing \cppinline{to_string} function must be used, which is implemented in  
\cppinline{run(get_declarator_type_text("parmVar"))}.
Otherwise, the \cppinline{to_string} function is generated in the same namespace as the enum declaration, so no prefix is necessary.

\begin{listing}[H]
    \begin{cppcode}
auto print_correct_name = ifBound("toString",
    run(get_declarator_type_text("parmVar")),
    cat(name("enumDecl")));
    \end{cppcode}
    \caption{Logic behind \cppinline{print_correct_name}.}
    \label{code:085tool:print_correct_name}
\end{listing}

The implementation of the stencil \cppinline{get_declarator_type_text} can be seen in \cref{code:085tool:get_declarator_type_text}.
The stencil operates on \cppinline{DeclaratorDecl}s, which can be considered an abstraction that incorporates the shared behaviour of specific declaration types, such as \cppinline{FunctionDecl} and \cppinline{VarDecl}.
It first extracts the \cppinline{SourceRange} from the node, converts it to a \cppinline{CharSourceRange} and extracts the corresponding text from the source file, which is finally returned.

\begin{listing}[H]
    \begin{cppcode}
resType get_declarator_type_text(StringRef Id) {
return [=](const MatchFinder::MatchResult &Match) -> Expected<std::string> {
    auto node = Match.Nodes.getNodeAs<DeclaratorDecl>(Id);
    if (!node) {
        throw std::invalid_argument("ID not bound or not DeclaratorDecl: " + Id.str());
    }
    auto sourceRange = node->getTypeSourceInfo()->getTypeLoc().getSourceRange();
    auto charRange = CharSourceRange::getTokenRange(sourceRange);
    auto sourceText = tooling::getText(charRange, *Match.Context).str();
    return sourceText;
};
}
    \end{cppcode}
    \caption{The \cppinline{get_declarator_type_text} stencil.}
    \label{code:085tool:get_declarator_type_text}
\end{listing}

\subsubsection*{Generating enum cases}
The final part in terms of node data processing, is to generate the case expressions inside the \cppinline{to_string} function, i.e., generate a case expression for each \cppinline{EnumConstantDecl} inside the enum declaration.

Given the complexity of the stencil, the group decided to employ the concept of ``function composition'' to combine several simpler stencils into a more intricate one.
This approach allows for the construction of a complex stencil by sequentially applying and composing simpler stencils.

The first stencil that was developed with such an approach, is \cppinline{foreach_enum_const} and can be seen in \cref{code:085tool:foreach_enum_const}.
The generic stencil allows for the execution of a callback function for each \cppinline{EnumConstantDecl} that is defined inside an \cppinline{EnumDecl} and concatenates the results into a single string.
The callback function is required to accept two parameters: A \cppinline{MatchResult} and an \cppinline{EnumConstantDecl*}. Additionally, the function should return a string as its result.
The specific function definition is enforced through metaprogramming techniques, although they are omitted from the example provided in the listing.

\begin{listing}[H]
    \begin{cppcode}
template <typename F>
resType foreach_enum_const(StringRef Id, F callback) {
	return [=](const MatchFinder::MatchResult &Match) -> Expected<std::string> {
		if (auto enum_decl = Match.Nodes.getNodeAs<EnumDecl>(Id)) {
			std::stringstream ss;
			for (const auto enum_const : enum_decl->enumerators()) {
				ss << callback(Match, enum_decl, enum_const);
			}
			return ss.str();
		}
		throw std::invalid_argument("ID not bound or not EnumDecl: " + Id.str());
	};
}
    \end{cppcode}
    \caption{The \cppinline{foreach_enum_const} stencil.}
    \label{code:085tool:foreach_enum_const}
\end{listing}

A stencil capable of generating case expressions for each \cppinline{EnumConstantDecl} was now required. This is seen in \cref{code:085tool:case_enum_to_string} where \cppinline{case_enum_to_string} is implemented.
The stencil is capable of generating a case expression for a single \cppinline{EnumConstantDecl}. It is then used in conjunction with \cppinline{foreach_enum_const} to iterate over each \cppinline{EnumConstantDecl}.

The stencil takes another stencil as a parameter that is used to retrieve the correct identifier to use in the switch case. In practice, this involves using \cppinline{print_correct_name} as seen in \cref{code:085tool:print_correct_name}.
The stencil then returns a string containing the complete case expression, e.g., \cppinline{case ns::Animal::Dog: return "Dog";}.

\begin{listing}[H]
    \begin{cppcode}
resType case_enum_to_string(StringRef Id, Stencil getName) {
	auto lambda = [getName](const MatchFinder::MatchResult &Match, const EnumDecl *enum_decl,
					   const EnumConstantDecl *enum_const_decl) {
			auto name = getName->eval(Match);
			if (!name) {
				throw std::invalid_argument("Could not get name");
			}
			return "\t\tcase " + name.get() +
				   "::" + enum_const_decl->getNameAsString() + ": return \"" +
				   enum_const_decl->getNameAsString() + "\";\n";
		};
	return foreach_enum_const(Id, lambda);
}
    \end{cppcode}
    \caption{The \cppinline{case_enum_to_string} stencil.}
    \label{code:085tool:case_enum_to_string}
\end{listing}

\subsection{Handling the results}
The results are handled identically to how it was done in the ``CStyle array converter'' tool \cref{sec:045tool:c_style_array}.

\section{CStyle array converter}\label{sec:045tool:c_style_array}

% TODO: This deserves a more detailed discussion
The traditional way of making arrays in C is by using the subscript operator. A C array consists of a type, a name and a constant size. The line: \cppinline{int my_array[10]} will create a variable called ``my\_array'' which is a collection of 10 consecutive integers. In C++11 a standard container called \cppinline{std::array} was added to C++. This container uses templates to create stronger typed arrays and to ensure the element type and the array size are known at compile time. This change gives the compiler more information about the intent of the code and potentially allows the backend of the compiler to make more optimisations. In C++ both ways of declaring arrays are allowed and the C way of declaration is called a CStyle array.

The goal of this tool is to find all the CStyle arrays in C++ code and convert them into \cppinline{std::array}s. This change provides more type information to the compiler without changing the intent of the code.

One of the test cases for this tool is to convert \cppinline{static const int* const const_pointer_const_array_static[2]} into \cppinline{static std::array<const int* const>, 2> const_pointer_const_array_static}. In order to achieve this, the storage class and qualifier of the type must be preserved through the transformation, which is a bigger challenge compared to the simple rename tool \cref{sec:085tool:example:simple_rename}.

\subsection{Command line parsing}

Like the renaming tool \cref{sec:085tool:example:simple_rename} the customization of the command line arguments for this tool has been left out in order to cut down on complexity.

\subsection{AST node matching}\label{subsec:085tool_example:030cstyle:node_matching}

This tool works on CStyle arrays with a constant size so the AST matcher for that type of node must be identified.

A CStyle array is a type and multiple matchers which match on different variants of CStyle arrays are provided by Clang. The types of CStyle arrays are: \cppinline{Array}, \cppinline{Constant}, \cppinline{DependentSized}, \cppinline{Incomplete} and \cppinline{Variable}. \\
The \cppinline{Array} type is a base type for all the other types of CStyle arrays. The \cppinline{Constant} arry type is a CStyle array with a constant size. The \cppinline{DependentSized} array is an array with a value dependent size. The \cppinline{Incomplete} array is a CStyle array with an unspecified size. The \cppinline{Variable} array type is a CStyle array wit ha specified size that is not an integer constant expression.

Each of the types have a corrosponding matcher which allows the creator of a tool to match only the wanted types of CStyle arrays. The focus of this tool is solely on \cppinline{Constant} arrays, as they are directly convertible to \cppinline{std::array}s. The same would probably also be true for the \cppinline{DependentSized} array type, but this has been left out in order to simplify the tool.

The constant array type node contains the element type of the array as well as the amount of elements. The constant array type node does not contain the storage specifier for the type (e.g., static or extern) so that information must be bound in another way. The storage specifier is stored in the declaration of the array which is a \cppinline{VarDecl}. For this tool the  The bound declaration will also make it easy to access the qualifiers for the CStyle array. 

There is a problem however, as this tool also aims to refactor the raw CStyle arrays declared inside of classes. This destinction matters for the declaration of the variables, as variables inside classes are \cppinline{FieldDecl}s and not \cppinline{VarDecl}s. For this matcher the type of node to match must therefore be more generic than the \cppinline{VarDecl}. This can be acchieved by using the \cppinline{DeclaratorDecl} matcher which matches on \cppinline{DeclaratorDecl}s, which is the common baseclass between \cppinline{VarDecl}s and \cppinline{FieldDecl}s.

The variable declaration for the arrays also contain the bounded location of the declaration in the source code. This can be easily extracted through the \cppinline{typeLoc} matcher. This information will make it easier to change the correct location in the source code in the following steps and is therefore pressent in the matcher.

\begin{listing}[H]
    \begin{cppcode}
auto ConstArrayFinder = 
    declaratorDecl(
        isExpansionInMainFile(),
        hasType(constantArrayType().bind("array")),
        hasTypeLoc(typeLoc().bind("arrayLoc")))
    .bind("arrayDecl");
    \end{cppcode}
    \caption{CStyle array matcher with bindings.}
    \label{code:085tool_ex:CSMatcher}
\end{listing}

\subsection{Node data processing}

In this section, the relevant data from the bound nodes will be extracted and used to generate source-code changes. The Stencil and Transformer libraries will be used for the data extraction and code refactoring.
As described in the previous section, there are multiple pieces of information which needs to be extracted from the nodes. 

From \cref{code:085tool_ex:CSMatcher} three node types were bound. ``array'' is the type of constant array that was found, ``arrayLoc'' is the location of the constant array in the source code and ``arrayDecl'' is the entire declartion of the array.

As shown in the introduction to this section, a test case for this tool is to convert \cppinline{static const int* const ID[2]} into \cppinline{static std::array<const int* const, 2> ID}.

\subsubsection*{RangeSelector}
The first thing needed in order to make the change is to extract the source code range from the nodes. The ``arrayLoc'' node, which has been bound, is a type location which spans the \cppinline{[2]} part of the CStyle array.
This may seem a bit confusing at first, but the behaviour is due to the \cppinline{typeLoc} referring to the underlying \cppinline{ArrayTypeLoc}, i.e., the part of the source-code that makes it a CStyle array.
``arrayLoc'' can be used in conjunction with the ``arrayDecl'' node in order to get the entire source code range for the array declaration. The \cppinline{RangeSelector} api has a convenience method \cppinline{encloseNodes} which is meant for exactly this purpose.

\subsubsection*{StorageClass}
Now that the correct source code range has been found, it is time to populate it with the correct information. As specified earlier the storage specifier for the decalaration must be kept and it can be found through the \cppinline{getStorageClass} method on VarDecl nodes. This method is not present in FieldDecl nodes because they don't have storage specifiers. static FieldDecls inside classes are converted to VarDecls during the AST generation, as these variables have no knowledge of the individual class instances. 

The \cppinline{getStorageClass} method can be implemented as a \cppinline{MatchConsumer<std::string>} which will make it easy to use the method to make source-code refactoring (see \cref{sec:080dev:tool_structure}). An implementation of such a method can be seen on \cref{code:085tool_ex:VarStorageString}.

\begin{listing}[H]
    \begin{cppcode}
auto getVarStorage(StringRef Id) {
    return [=](const MatchFinder::MatchResult &Match) -> Expected<std::string> {
        if (auto var = Match.Nodes.getNodeAs<VarDecl>(Id)) {
            auto storage_class = var->getStorageClass();
            if (storage_class != StorageClass::SC_None) {
               return std::string(VarDecl::getStorageClassSpecifierString(storage_class)) + " ";
            }
        }

        return "";
    };
}
    \end{cppcode}
    \caption{Method to extract the storage specifier string from a VarDecl node bound to Id.}
    \label{code:085tool_ex:VarStorageString}
\end{listing}

\subsubsection*{Array element type}

The array element type is stored inside the \cppinline{ConstantArrayType} node. It can be accessed through the \cppinline{getElementType} method call. Like the storage class specifier on \cref{code:085tool_ex:VarStorageString} the easiest way to work with the element type for this tool is through the Stencil library. The getArrayElementType method will therefore be implemented as a MatchConsumer. The implementation of the method can be seen on \cref{code:085tool_ex:ArrayElemtType}. 

\begin{listing}[H]
    \begin{cppcode}
auto getArrayElementType(StringRef Id) {
    return [=](const MatchFinder::MatchResult &Match) -> Expected<std::string> {
        if (auto array = Match.Nodes.getNodeAs<ArrayType>(Id)) {
            return array->getElementType().getAsString();
        }

        throw std::runtime_error(
			    append_file_line("ID not bound or not ArrayType: " + Id.str()));
    };
}
    \end{cppcode}
    \caption{Method to extract the element type from the ConstantArrayType node.}
    \label{code:085tool_ex:ArrayElemtType}
\end{listing}

\subsubsection*{Array size}

The size of the array can also, like the array element type, be extracted through the ConstantArrayType node. The implementation of the extraction method can be seen on \cref{code:085tool_ex:ConstArraySize}.

\begin{listing}[H]
    \begin{cppcode}
auto getConstArraySize(StringRef Id) {
    return [=](const MatchFinder::MatchResult &Match) -> Expected<std::string> {
        if (auto array = Match.Nodes.getNodeAs<ConstantArrayType>(Id)) {
            auto size = array->getSize().getZExtValue();
            std::stringstream ss;
            ss << size;
            return ss.str();
        }

        throw std::runtime_error(
			    append_file_line("ID not bound or not ConstantArrayType: " + Id.str()));
    };
}
    \end{cppcode}
    \caption{Method to extract the element size from the ConstantArrayType node. The array size is a llvm::APInt and must be converted to a \cppinline{uint64_t} through the \cppinline{getZExtValue} method.}
    \label{code:085tool_ex:ConstArraySize}
\end{listing}

\subsubsection*{Declaration qualifiers}

The last piece of the puzzle is to keep the qualifiers of the declaration. The qualifiers are the explicit namespaces in front of the name of the declaration. E.g., \cppinline{uint8_t my_namespace::array[5];} has the qualifiers \cppinline{my_namespace::}, while \cppinline{uint8_t array[4];} has no qualifiers. These qualifiers are part of the declaration and the easiest way to extract them is to copy the literal text in the source code. The literal source code of declarations can be extracted through the source range of the node. \cref{code:085tool_ex:DeclaratorQualif} shows how the qualifiers of a \cppinline{DeclaratorDecl} can be extracted from the source-code.

\begin{listing}[H]
    \begin{cppcode}
auto getDeclQualifier(StringRef Id) {
    return [=](const MatchFinder::MatchResult &Match) -> Expected<std::string> {
        if (auto decl = Match.Nodes.getNodeAs<DeclaratorDecl>(Id)) {
            CharSourceRange qualifierRange = getTokenRange(decl->getQualifierLoc().getSourceRange());
            return getText(qualifierRange, *Match.Context).str();
        }

        throw std::runtime_error(
			    append_file_line("ID not bound or not DeclaratorDecl: " + Id.str()));
    };
}
    \end{cppcode}
    \caption{Method to extract the qualifiers from the source code range of a DeclaratorDecl node.}
    \label{code:085tool_ex:DeclaratorQualif}
\end{listing}

\subsubsection*{Creating the transformation rule}

With all the relevant information extracted from the bound nodes, a transformation rule can be made to create the wanted source-code refactoring. The code for the rule can be found on \cref{code:085tool_ex:Rule}.

\begin{listing}[H]
    \begin{cppcode}
auto CStyleArrayConverterRule = makeRule(
    ConstArrayFinder,
    {
        addInclude("array", IncludeFormat::Angled),
        changeTo(
            encloseNodes("arrayDecl", "arrayLoc"),
            cat(run(getVarStorage("arrayDecl")),
                "std::array<",
                run(getArrayElementType("array")),
                ", ",
                run(getConstArraySize("array")),
                "> ",
                run(getDeclQualifier("arrayDecl")),
                name("arrayDecl")
            )
        )
    });
    \end{cppcode}
    \caption{The entire rule for generating the wanted \cppinline{std::array} declaration. The rule both adds the \cppinline{<array>} header and makes the source-code refactoring in one step.}
    \label{code:085tool_ex:Rule}
\end{listing}

As it can be seen from \cref{code:085tool_ex:Rule}, the refactoring rule is relatively simple to read, as it solely uses the methods created through this section and strings of text, which is very descriptive. This makes each line easy to reason about and transparent. The difference between node processing step for the CStyleConverter tool as compared to the RenamingTool, is that more information has to be extracted from the bound nodes. This requires a deeper understanding of which node types contain the wanted information, and how the information is encoded in the nodes.

In the renaming tool (\cref{sec:085tool:example:simple_rename}) the \cppinline{Tranformer} consumer extracted the \cppinline{Replacements} from the \cppinline{AtomicChanges} generated by the rule. This was necessary, as the tool used the \cppinline{RefactoringTool} class provided by the library. In the renaming tool, the rule only had a single change for the matches, which was quite easy to extract from the \cppinline{AtomicChanges}. In this tool, the rule adds multiple changes and it even includes the \cppinline{array} header. This added complexity to the extraction of the replacements in the consumer. 
'
During the development of this tool it was discovered, that there is a convenience method in the library that allows the developer to apply \cppinline{AtomicChanges} directly to the source code instead of unpacking it manually. This method will take care of all the header removals and includes in each \cppinline{AtomicChange}. The team wanted to use this feature in the tool to reduce the complexity of the consumer, so a custom \cppinline{ClangTool} class had to be created.

The custom class has to work with \cppinline{AtomicChanges} instead of \cppinline{Replacements} but the overall structure of the \cppinline{runAndSave} method, which saves the changes to disk, is the same. As opposed to \cppinline{Replacement} objects,\cppinline{AtomicChange} objects already contain the file name for the change so all the changes can be inserted into a single \cppinline{std::vector}  and handled by the tool instead of the consumer. This change in semantics is what makes the consumer method simpler. 

The new consumer method takes a \cppinline{AtomicChanges} reference as a parameter and returns a lambda method which is a \cppinline{ChangeSetConsumer}. The lambda inserts valid \cppinline{AtomicChange} objects into the provided \cppinline{AtomicChanges} array for later processing. The implementation can be seen on \cref{code:085tool_ex:030cstyle:consumer_impl}.

\begin{listing}[H]
    \begin{cppcode}
auto RefactorConsumer(AtomicChanges &Changes) {
        return [=](Expected<TransformerResult<void>> C) {
            if (!C) {
                throw std::runtime_error("Invalid Changes! " + toString(C.takeError()));
            }

            Changes.reserve(Changes.size() + C.get().Changes.size());
			std::move(C.get().Changes.begin(), C.get().Changes.end(),
			          std::back_inserter(Changes));
        };
}
    \end{cppcode}
    \caption{Implementation of the \cppinline{AtomicChange} consumer.}
    \label{code:085tool_ex:030cstyle:consumer_impl}
\end{listing}

\subsection{Handling the results}

In the previous section, a new consumer was made for the \cppinline{Transformer}. This consumer uses an external instance of \cppinline{AtomicChanges} to save the results of the tool. After all the \cppinline{AtomicChange} objects have been gathered, the changes can be applied to the source code and saved to disk - like it was done in the renaming tool. This logic has to be custom-made to use \cppinline{AtomicChange} instead of \cppinline{Replacements}. This change will be discussed here.

The renaming tool calls the \cppinline{runAndSave} method on the \cppinline{RefactoringTool} class. This method first runs the specified \cppinline{FrontEndAction} to get the result of the tool. Afterwards, it creates a \cppinline{Rewriter} with sources provided to the tool. The \cppinline{Rewriter} class is an interface between the tool and the rewrite buffers - aka the OS. This \cppinline{Rewriter} will allow the tool to make source-code changes. With the created \cppinline{Rewriter} object, the \cppinline{RefactoringTool} calls the \cppinline{applyAllReplacements} and \cppinline{saveRewrittenFiles} methods. These methods will apply the \cppinline{Replacements} to the original source-code and then save the rewritten source to disk. It is this behaviour that needs to be reimplemented for the \cppinline{AtomicChanges}.

The creation of the \cppinline{Rewriter} class is identical between the implementation in the library and the custom version. This is the case, because the \cppinline{Rewriter} is used solely to apply the changes and not to reason about the changes. The creation of the \cppinline{Rewriter} instanche has thus been excluded from this report. It can be found in the implementation of the CStyleArrayConverter on the project github page. 

The \cppinline{applyAllReplacements} method is where the custom tool class gets interesting. This method has to be created by hand and it needs to call the \cppinline{applyAtomicChanges} method on all the gathered \cppinline{AtomicChanges} for each filename. The \cppinline{applyAtomicChanges} method can apply changes from multiple \cppinline{AtomicChange} objects at once, but they must be changes to the same source file. This has to be checked by the developer before the method is called. This check was performed in the consumer in the RenamingTool but has to be implemented in the tool here. 

In order to apply all the gathered changes, the tool needs access to those changes. In the \cppinline{RefactoringTool}, the \cppinline{Replacements} container was a part of the tool instance. This part will be copied into the custom tool, so it contains an instance of the \cppinline{AtomicChanges}. 

The \cppinline{AtomicChange} objects each contain the name of the file which the changes should be applied to. Because this information is present in the objects they can be grouped by their source files in a map. The grouping is shown in \cref{code:085tool_ex:030cstyle:SortChanges}.

\begin{listing}[H]
    \begin{cppcode}
AtomicChanges Changes;
bool applyAllChanges(Rewriter &Rewrite) {
    std::unordered_map<std::string, AtomicChanges> FileChanges;
    for (const auto& Change : Changes) {
        FileChanges[Change.getFilePath()].push_back(Change);
    }
    ...
}
    \end{cppcode}
    \caption{Code snippet that will group the collection of \cppinline{AtomicChange} objects based on the files they should change. The use of the unordered map is for performance reasons and could just as easily be a \cppinline{std::map}.}
    \label{code:085tool_ex:030cstyle:SortChanges}
\end{listing}

Now that the changes have been grouped, it is time to apply the changes. In order to apply the changes, the specific source code and the file handle have to be used. This information can be extracted from the \cppinline{Rewriter} through its internal \cppinline{SourceManager} and \cppinline{FileManager} using the file path stored in the groups. In order to get access to the source file from a given path, first an \cppinline{FileEntryRef} is extracted from the \cppinline{FileManager}. Then the \cppinline{SourceManager} can be used to create a \cppinline{FileID}, which can be used to access the source code. The created \cppinline{FileID} can also be used to specify the range which should be overwritten by the \cppinline{Rewriter}. Putting all of this together will commit the found file changes to disk. The implementation of this method can be seen on \cref{code:085tool_ex:030cstyle:apply_changes}.

\begin{listing}[H]
    \begin{cppcode}
bool applyAllChanges(Rewriter &Rewrite) {
    // Group the Changes
    ...

    auto &sm = Rewrite.getSourceMgr();
    auto &fm = sm.getFileManager();

    for (const auto &[File, ChangesForFile] : FileChanges) {
        auto Entry = fm.getFileRef(File); 
        if (!Entry) {
            llvm::errs() << Entry.takeError();
            return false;
        }

        auto id = sm.getOrCreateFileID(Entry.get(), SrcMgr::C_User);

        auto code = sm.getBufferData(id);
        auto new_code = applyAtomicChanges(File, code, ChangesForFile, ApplyChangesSpec());

        if (!new_code) {
            llvm::errs() << new_code.takeError();
            return false;
        }

        Rewrite.ReplaceText(
            SourceRange(sm.getLocForStartOfFile(id), sm.getLocForEndOfFile(id)), new_code.get());
    }
    
    return Rewrite.overwriteChangedFiles();
}
    \end{cppcode}
    \caption{Implementation of the \cppinline{applyAllChanges} method which will apply all the generated \cppinline{AtomicChanges} to the source code and save it to disk.}
    \label{code:085tool_ex:030cstyle:apply_changes}
\end{listing}






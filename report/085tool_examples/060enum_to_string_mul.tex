\section{Enum to string -- multiple steps}

There are few differences between the multi-step and single-step enum-to-string tools and they are all in either the matching or the node processing steps. However, the command line and result handling are identical between the two tool types.

The structure of the tool, as shown in \cref{code:085tool:pseudo_enum2}, is to first find, log and update all the existing ``to\_string'' methods and secondly to generate ``to\_string'' methods for the rest of the enum declarations.
This will be done with two \cppinline{ClangTool}s that are executed in succession. These are respectively denoted the ``to\_string'' and the enum declaration tools. The rest of the section is structured by consecutively describing the relevant parts of each tool.

\subsection{AST node matching -- ``to\_string'' tool}
In the multi-step version, there is no longer a need to recursively traverse the declaration context through \cppinline{matchers::has_rec_decl_context(...)}.
However, the \cppinline{functionDecl} matcher from \cref{code:085tool:has_enum_to_string} can be reused.\\
Additionally, the matcher in this version is intended to find all ``to\_string'' methods and not a specific one, so the complicated comparison between the parameter type and the bound enum declaration can be left out.
The ``to\_string'' matcher for this version of the tool can be seen on \cref{code:085tool:060enum:to_string_matcher}.

\begin{listing}[H]
    \begin{cppcode}
auto to_string_matcher = functionDecl(
  isExpansionInMainFile(),
  hasName(to_string_method),
  hasParameter(0, 
    parmVarDecl(
	  hasType(
	    enumDecl().bind("enumDecl"))).bind("enumParm"))).bind("toString");
    \end{cppcode}
    \caption{The final ``to\_string'' matcher for the multi-step version of the enum-to-string tool.}
    \label{code:085tool:060enum:to_string_matcher}
\end{listing}

\subsection{Node data processing -- ``to\_string'' tool}
The node data processing needed to update the existing ``to\_string'' functions is similar to how it was done in the single-step tool.
However, the ``to\_string'' tool also needs to log which \cppinline{EnumDecl}s were used as parameter in the updated ``to\_string'' functions, for the second part of the multi-step tool.
Two challenges were identified regarding this: How to log an \cppinline{EnumDecl} and how to use the logged declarations for filtering.

Logging a declaration consists of recording data from the node and saving it for later usage.
When logging an \cppinline{EnumDecl} it is necessary to identify a unique way of classifying the specific \cppinline{EnumDecl}. There are multiple conceivable ways of doing this.
One way could be to save the source code location of the declaration. Another could be to save the fully qualified name of the declaration\footnote{The fully qualified name is the name of the declaration with all the namespaces, and it can be used as a unique identifier as this is required by the C++ specification.}.
The choice of data representation should align with the filtering methodology. In this case, the matcher \cppinline{hasAnyName} will be used, and its details will be provided in the forthcoming section.
However, it is worth mentioning that \cppinline{hasAnyName} expects a vector of names, hence making it the designated data representation.

Due to the decision of using \cppinline{hasAnyName}, the fully qualified names had to be extracted from the bound \cppinline{EnumDecl}s.
This can be done through a stencil, which takes the id as well as a vector, for the names, as parameters.
The fully qualified name can be extracted from any \cppinline{NamedDecl} with the method\\
\cppinline{getQualifiedNameAsString} and then inserted into the vector. 
The implementation of the function can be seen on \cref{code:085tool:060enum:tool1_node_processing}.

\begin{listing}[H]
  \begin{cppcode}
auto addNodeQualNameToCollection(StringRef Id, std::vector<std::string> *decls) {
	auto lambda = [=](const MatchResult &Match) -> Expected<std::string> {
		if (auto *decl = Match.Nodes.getNodeAs<NamedDecl>(Id)) {
			decls->emplace_back("::" + decl->getQualifiedNameAsString());
			return "";
		}
		throw std::invalid_argument(append_file_line("ID not bound or not NamedDecl: " + Id.str()));
	};
	return lambda;
}
  \end{cppcode}
  \caption{The implementation of the function which extracts the fully qualified name of a bound \cppinline{NamedDecl}. The addition of the ``::'' on line 4 will be further discussed in the upcoming section.}
  \label{code:085tool:060enum:tool1_node_processing}
\end{listing}

\pagebreak
\subsection{AST node matching -- enum declaration tool}\label{subsubsec:080dev:085examples:060enum:matching_second_tool}
The node matching for the enum declaration part of the tool is similar to the single-step tool, except it must also handle the aforementioned filtering.
When working with LibTooling, utilizing a narrowing matcher is often the simplest approach to implementing a node filter.
By looking through the reference of the built-in matchers, the  \cppinline{hasAnyName} matcher was discovered.
This matcher compares the name of a \cppinline{NamedDecl}\footnote{\cppinline{ValueDecl}s, such as an \cppinline{EnumDecl}, all inherit from the \cppinline{NamedDecl} class.} to a vector of names and returns true if the name matches any of the specified names.
Since the desired behaviour is the opposite, the matcher \cppinline{unless} can be used to logically invert the expression.
The availability of \cppinline{hasAnyName} ultimately led to the decision of using the fully qualified name of the \cppinline{EnumDecl}s as the identifier.

The matcher for the enum declaration tool can be seen in \cref{code:085tool:060enum:tool2_matcher}, with most of it being reused from the single-step tool.

\begin{listing}[H]
  \begin{cppcode}
auto find_other_enums = enumDecl(
    isExpansionInMainFile(),
    matchers::is_named(),
    unless(hasAnyName(existing_enums))
  ).bind("enumDecl");
  \end{cppcode}
  \caption{The matcher for finding enum declarations with no existing ``to\_string'' function. \cppinline{existing_enums} is a vector of fully qualified names of the enums }
  \label{code:085tool:060enum:tool2_matcher}
\end{listing}

It is important to note that due to the internal workings of the \cppinline{hasAnyName} matcher, the first tool needs to be executed before instantiating this matcher.
This is because \cppinline{hasAnyName} creates a copy of the names in the collection at instantiation time.
Another thing to note about the \cppinline{hasAnyName}, is that it has two modes that define its behaviour.
If none of the names in the provided collection contains ``::'', then the matcher will do a non-qualified check on the AST. If however, any of the names contain the ``::'' string, then the matcher will use a fully qualified name check. In this tool, the fully qualified should be used in all cases, and this is the reason for the addition of the ``::'' on line 4 of \cref{code:085tool:060enum:tool1_node_processing}.

\subsection{Node data processing -- enum declaration tool}

The node data processing for the second tool is similar to the single-step tool. The difference between the two is that all the existing ``to\_string'' methods have been handled, so the dynamic \cppinline{RangeSelector} can be removed in favour of placing the ``to\_string'' function after the declaration of the enum.
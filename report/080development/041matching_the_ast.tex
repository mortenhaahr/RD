

\subsection{Matching the AST}

The first step in working with LibTooling is to find the AST that is releavant for the tool. This is a very important part of the tool development as the matching defines what kind of information is avaliable for the later stages of the tool. If the wrong AST nodes are matched, the later processing becomes unessesarily complex and complicated.

The easiest way to do that is by creating or finding a very simple example of the code that should be changed. The entire AST for that file can be dumped through clang by invoking: \bashinline{clang -cc1 -ast-dump input_file}. 
This command will print all the AST information in the input file to the console, which can then be analysed manually for the wanted nodes/patterns.

After an AST node has been identified as interesting for the tool it should be matched. The way to create a matcher in LibTooling is by using the predefined matchers in the LibTooling framework.\cite{ASTMatcherReference} Custom matchers can be made and they are a very powerfull tool when the standard matchers are lacking. The builtin matchers are however enough most of the time and they should therefore be the default place to look when creating a matcher. 

%TODO: write about custom matchers
The first step when creating a matcher is to get the wanted node through a Node matcher. Theese are the matchers witch allows one to match some kind of node type and bind it to an identifier. Binding a node allows it to be used in the later stages of tool processing. The node matchers will often match quite a bit of nodes. The amout of matches can be controlled through the use of Narrowing matchers which allows the tool authors to filter the matches E.G. only match variable declarations with a constant array type.

The creation of the matcher is therefore an iterative process where nodes are matched and the matches are narrowed untill the tool is left with the nodes that contain the needed information. The matching iterations should stop when all the wanted nodes are matched. The information inside the matches can be extracted later through the stencil library, which will be described in \cref{subsec:080stencils}. 

\subsection{Stencils} \label{subsec:080stencils}

The \href{https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/Stencil.h}{stencil library} is used to extract information from bound nodes and convert the information to strings.  The stencil library is an abstraction on top of \cppinline{MatchComputation<std::string>} which is called on matched nodes through the Transformer API. 

Examples of usecases for the stencil library could be to extract the element type of an array or to issue a warning at a given location. The methods in the stencil library are primarily focused on control flow, concatination of stencils and expression handling. Therefore it is very likely that the creator of a tool will have to create custom stencils to extract the nessecary data from the bound nodes.

Luckily the stencil library allows the simple conversion from \cppinline{MatchConsumer<std::string>} to a \cppinline{Stencil} through the \cppinline{run} method. The \cppinline{MatchConsumer<T>} type is a typename for \cppinline{std::function<Expected<T>(const ast_matchers::MatchFinder::MatchResult &)>} with \cppinline{std::string} as the template parameter. This API allows the creator of a tool to write small methods that extract the nessecary information from a bound node as a string and seamlessly concatinate them together through the \cppinline{cat} method from the stencil library.

All the stencils in the stencil library return strings but it is possible to create an identical library that returns any type of data if that is required for the tool. The reason the stencil library works solely with strings is because it is primarily used to generate source code changes which must be converted to strings in some way or form in order to be written to disk. 

Along with the stencil library is a \href{https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RangeSelector.h}{range selector library}. The range selector library also uses the \cppinline{MatchConsumer<T>} API but with \cppinline{RangeSelector} as an output instead of strings. This library contains convenience methods to select ranges of bound nodes. It is also possible to select locations right before or right after a bound node. This feature allows the tool implementor to add source code exactly where they want it.

\subsection{Combining matchers and stencils}

In order to create a tool it is nessecary to have both matchers and stencils and the tool authors must therefore consider how they should be combined.

There are two approaches when combining the matcher and the stencils. The fist approach is to have the matcher bind only the top node and then extract all the information from the node through stencils. The other mehtod is to bind multiple nodes inside the matcher to get access to the important information. Both approaches can be used for the same purpose but the implmentations look vastly different.
 
If the implementor chooses the first combination method, then the stencils can become rather complicated because they have to filter and extract information from the node. 

If the second method is chosen instead, then the complexity of extracting information from the nodes is placed inside the mathcer. This can lead to complicated matchers with many bound subnodes. The stencils that extract information from the bound nodes are however much simpler. When using this mehtod it can be hard to tell when all the nessecary information has been bound and the developers can be stuck looking for a matcher that binds to exactly the information needed when it could easily be extracted from a higher node.

It is always possible to refactor later, so the developers of the tool should consider the two approaches carefully and choose their battles wiesly.
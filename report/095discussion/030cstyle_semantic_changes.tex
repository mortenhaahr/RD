% Discuss the semantic changes that were made through this C-style array tool - focus on the calling convention to methods.

\section{Semantic considerations}
In this section, some of the semantic considerations that were processed and discovered during the development of the C-style array conversion tool will be discussed.
The C-style array tool in particular led to many discussions regarding language semantics, as the transformation is non-trivial when all potential scenarios must be considered.

\subsection{Array conversions for constant types} \label{subsec:095:030:array_conversions}

The conversion from a C-style \cppinline{int[5]} array to a \cppinline{std::array} is straightforward. The type and size are moved inside the template parameter list, e.g., \cppinline{int array[5]} becomes \cppinline{std::array<int, 5> array}.

A more interesting scenario to consider is how to handle a C-style array of constant integers\\
(\cppinline{const int array[5]}). For this conversion, there are two possibilities. Either with a constant \cppinline{std::array} declaration
(\cppinline{const std::array<int, 5> array}), or with a constant template parameter\\
(\cppinline{std::array<const int, 5> array}).
The two solutions are almost identical in meaning, as they will both prevent the programmer from changing the elements inside the \cppinline{std::array}.
The difference between the two approaches is that the non-const member functions\footnote{
    An example of a non-const qualified member function for \cppinline{std::array} is \cppinline{swap} that swaps the contents of two arrays.
} are unavailable for \cppinline{const std::array<..>} version, as it follows the normal rules for const-qualified member functions.
They are technically available to the other version, but calling them will result in a compile-time error as the functions will attempt to modify the values of the \cppinline{const int}s.
As a result, the main distinction for the programmer lies in the type of compile-time error that occurs and the readability of the code.\\
For readability of the code and the error messages, the group prefers the \cppinline{const std::array<..>} representation.
However, in the implementation of the conversion tool, the std::array<const ...> version is created. This choice is made because it is easier in LibTooling to extract the entire array element type, including the const qualifier, than it is to separate the two.
Since the difference between the two versions is so minimal the ease of development was prioritised.

\subsubsection*{Pointer arrays}
Similar considerations have to be made regarding pointers but they are perhaps more interesting, as they can have multiple const qualifiers.
They can either be pointers to constant objects, constant pointers to objects or constant pointers to constant objects (respectively \cppinline{const int*}, \cppinline{int* const} and \cppinline{const int* const}) \cite{cppreferencePointerDeclarationCppreference}.
% TODO: You are here Morten
Like the value arrays the three types of pointer arrays can be converted directly to \cppinline{std::array}s by moving the type into the template parameter list. E.g. \cppinline{const int*[4]} => \cppinline{std::array<const int*, 4>} and \cppinline{int* const[4]} => \cppinline{std::array<int* const, 4>}.

There is however another way to represent a constant array and that is \cppinline{const std::array<...>}. The question is then, is the const array equal to \cppinline{std::array<const int*, 4>} or \cppinline{std::array<int* const, 4>} or is it equal to both. If it is equal to both then it should not be used as that would imply that there is no way to distinguish what type of array it was meant to be. An easy way to test the equivalence between the representations is by creating a test struct with a non-const member method and trying to call it on an element through an array. This test can be seen on \cref{code:095:discussion:test_of_array_conversion_eq}.

\begin{listing}[H]
    \begin{cppcode}
struct Test {void test(){}};
int main() {
    Test t;
    const std::array<Test*, 1> a0 {&t};
    std::array<const Test*, 1> a1 {&t};
    std::array<Test* const, 1> a2 {&t};
    a0[0]->test();
    a1[0]->test();
    a2[0]->test();
}
    \end{cppcode}
    \caption{Test of conversion equivalence.}
    \label{code:095:discussion:test_of_array_conversion_eq}
\end{listing}

If the test code is passed through a C++ compiler it will show that the \cppinline{a1[0]->test()} line will fail to compile, while the other two definitions are valid. This means that \cppinline{const std::array<int*, 4>} and \cppinline{std::array<int* const, 4>} are identical except for the differences discussed earlier for the non-pointer array types. The implementation in the tool uses the \cppinline{std::array<int* const, 4>} version as it is easier to extract from the AST nodes.

\subsection{Array parameter conversions}\label{subsec:095disc:arrayParm}
% Pointer decay for methods:
% non converted raw arrays?
% Dynamic arrays accessed through a raw pointer?
% Other container types? vectors or lists?
% Const array element types?
% What about the call sites?


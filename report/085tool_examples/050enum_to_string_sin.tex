\section{Enum-to-string -- single step}
The following section describes the enum-to-string tool where the entire tool is implemented as a single \cppinline{ClangTool}.

\subsection{Command line parsing}
Most of the command line parsing was done in a similar manner as in \cref{sec:085tool:example:simple_rename}. However, the behaviour was extended with the introduction of some new command line options for the user to specify.
The command-line option ``in\_place'' was introduced, allowing the user to have the filechanges be written to the terminal instead of directly to the file.
The other option ``debug\_info'' makes the tool print extra debug information to the console.

The additional options were easily introduced as booleans options through the LLVM command line API, as seen in \cref{code:085tool:sin_cl_options}. One simply needs to specify a description and add it to the \cppinline{OptionCategory} -- which is \cppinline{MyToolCategory} in this case.

\begin{listing}[H]
    \begin{cppcode}
static llvm::cl::opt<bool> Inplace(
    "in_place",
    llvm::cl::desc("Inplace edit <file>s, if specified. If not specified the "
                   "generated code will be printed to cout."),
    llvm::cl::cat(MyToolCategory));
static llvm::cl::opt<bool> DebugMsgs(
    "debug_info", llvm::cl::desc("Print debug information to cout."),
    llvm::cl::cat(MyToolCategory));
    \end{cppcode}
    \caption{Implementation of the newly introduced command line options.}
    \label{code:085tool:sin_cl_options}
\end{listing}

The options can then be used as normal booleans throughout the implementation, as seen in \cref{code:085tool:sin_cl_in_place}.

\begin{listing}[H]
    \begin{cppcode}
if (!Inplace) {
    llvm::outs() << new_code.get();
}
    \end{cppcode}
    \caption{Using the \cppinline{Inplace} command line option to print the changes to the command line if \textinline{--in_place} was not specified when running the tool.}
    \label{code:085tool:sin_cl_in_place}
\end{listing}

The addition of ``in\_place'' option is in particular useful for the future development of tools, as it allows for better system testing, where testcases are written that compares the contents of a virtual file, before and after running the tool.
Similar tests can throughout the tools in the LLVM repository.

\subsection{AST node matching}\label{subsec:085tool:enum_node_matching_sin}

The AST node matching was by far the most challenging part of developing this tool as one needs to write a matcher that implements the following logic for each enum declaration:

\vspace*{-0.75em}
\begin{enumerate}
    \item Find and bind enum declaration
    \item Find the outermost namespace
    \item Recursively traverse the namespace to potentially find a matching \cppinline{to_string} function
\end{enumerate}

The behaviour described above is a quite complex compared to the previous tools and required the implementation of custom matchers that worked recursively, something that the builtin matchers do not support.

The matcher will be described in steps below.

\subsubsection*{Finding enum declarations}
A matcher for finding the enum declarations can be seen in \cref{code:085tool:sin_enum_finder} with the parts related to finding the \cppinline{to_string} functions left out.
The matcher is fairly straight-forward with the exception of line 4 and and 5. These are discussed below the listing.

\begin{listing}[H]
    \begin{cppcode}
auto enumFinder = enumDecl(
        isExpansionInMainFile(),
        has(enumConstantDecl(hasDeclContext(enumDecl().bind("enumDecl")))),
        matchers::is_named(),
        optionally(
            // Find matching enum_to_string
        ));
    \end{cppcode}
    \caption{Matcher for finding enum declarations.}
    \label{code:085tool:sin_enum_finder}
\end{listing}

The intention of line 3 in \cref{code:085tool:sin_enum_finder} is simply to bind the enum declaration, similarly to how it was done with other declarations in the previous tools.
However, the implementation is different from the other tools, since the binding is required by the matcher that is responsible for finding the matching \cppinline{to_string} functions.
I.e., if the implementation was written as \cppinline{enumDecl(optionally(/*find to_string*/)).bind("enumDecl)}, the ``enumDecl'' binding would not be accessible to the ``to\_string'' matcher, as the outer binding does not happen until all the inner matchers are evaluated.
Therefore, it was necessary to make the binding earlier, and line 3 is a way of achieving this.\\
The behaviour of the line is to go to the child in the AST of the enum declaration by entering the enum constant\footnote{
    Note that this also filters out empty enum declarations which are uninteresting in terms of having a \cppinline{to_string} function.
}, and then going back to the parent, i.e., the enum declaration. This allows the enum declaration to be bound before running the ``to\_string matcher''.

Line 4 in \cref{code:085tool:sin_enum_finder} fixes a bug that was found when running the tool on an external project, i.e., the JSON \cite{Lohmann22}.
Before the line was introduced, the tool was unable to handle unnamed enums
\footnote{
    Unnamed enums were mainly used in C++ before \cppinline{constexpr} was introduced, for defining compile-time evaluated constants for metaprogramming usages.
}, which would throw an unhandled exception.\\
In the AST, an \cppinline{EnumDecl} inherits from a \cppinline{NamedDecl}, which contains the \cppinline{IdentifierInfo} related to the node.
An unnamed enum can be interpreted as a \cppinline{NamedDecl} with no \cppinline{IdentifierInfo} since it does not have a name.
The matcher can therefore be written as \cppinline{code:085tool:sin_is_named}, where the \cppinline{IdentifierInfo*} is implictly converted to a boolean, returning false in it is a nullptr.

\begin{listing}[H]
    \begin{cppcode}
AST_MATCHER(NamedDecl, is_named) {
	return Node.getIdentifier(); // nullptr if no name
}
    \end{cppcode}
    \caption{Custom matcher for determining if a \cppinline{NamedDecl} has been given a name.}
    \label{code:085tool:sin_is_named}
\end{listing}

\subsubsection*{Finding the outermost namespace}
In order to potentially find the \cppinline{to_string} method matching the \cppinline{EnumDecl}, one most consider that the function might be placed inside a different namespace than the \cppinline{EnumDecl}.
For that reason, it is necessary to to consider all the namespaces inside the compilation unit when searching.
The implementation for such a matcher is somewhat similar to the implemention of the builtin \cppinline{hasDeclContext} that was used in \cref{code:085tool:sin_enum_finder}. 
The behaviour of \cppinline{hasDeclContext} is to return false, if the declaration does not have a \cppinline{DeclContext}\footnote{
    An example of a case of a \cppinline{Decl} that does not have \cppinline{DeclContext} is the outermost \cppinline{TranslationUnitDecl}.
}, otherwise return the result of evaluating the \cppinline{InnerMatcher} on the context casted to a \cppinline{Decl}.\\
The behaviour for the recursive version (\cppinline{has_rec_decl_context}) is similar, but instead of evaluating to the immediate parent context, it is evaluated to the outermost context. The implementation can be seen in \cref{code:085tool:sin_rec_decl}.

\begin{listing}[H]
    \begin{cppcode}
AST_MATCHER_P(Decl, has_rec_decl_context, Matcher<Decl>, InnerMatcher) {
	auto cur_ctx = Node.getDeclContext();
	if (!cur_ctx) {
		return false;
	}
	const DeclContext *nxt_ctx = nullptr;
	while (true) {
		nxt_ctx = cur_ctx->getParent();
		if (!nxt_ctx) {
			return InnerMatcher.matches(*Decl::castFromDeclContext(cur_ctx), Finder, Builder);
		}
		cur_ctx = nxt_ctx;
	}
}
    \end{cppcode}
    \caption{Custom matcher for finding the outermost context of an AST node.}
    \label{code:085tool:sin_rec_decl}
\end{listing}

\subsubsection*{Find matching ``to\_string''}
The remaining part of the \cppinline{enumFinder} matcher that was seen in \cref{code:085tool:sin_enum_finder} is to potentially identify the \cppinline{to_string} functions. The implementation can be seen in \cref{code:085tool:has_enum_to_string} with a description below the listing.

\begin{listing}[H]
    \begin{cppcode}
auto enumFinder = enumDecl(
  /* The rest of enumFinder...*/
  optionally(
    matchers::has_rec_decl_context(hasDescendant(
      functionDecl(
        hasName("to_string"),
        parameterCountIs(1),
        hasParameter(0,
          parmVarDecl(hasType(
            elaboratedType(namesType(
              hasDeclaration(
                equalsBoundNode("enumDecl")))))
          ).bind("parmVar"))
      ).bind("toString")))));
    \end{cppcode}
    \caption{The part of the \cppinline{enumFinder} matcher that was left out of \cref{code:085tool:sin_enum_finder}. It is responsible of optionally finding a \cppinline{to_string} function matching the ``enumDecl''.}
    \label{code:085tool:has_enum_to_string}
\end{listing}


The \cppinline{optionally} matcher indicates that the inner expressions are not required and \cppinline{has_rec_decl_context} is then used to traverse to the outermost context.
Curiously enough, unlike \cppinline{hasDeclContext}, the \cppinline{hasDescendant} function recursively matches on the descendants. This means that it can be utilized to recursively match the \cppinline{functionDecl}s.
Furthermore, the \cppinline{functionDecl} must have the name ``to\_string'' and take a single parameter, that is of the same type as ``enumDecl''.
The latter can be expressed by defining that the \cppinline{parmVarDecl} has a type (\cppinline{hasType}) that is an \cppinline{elaboratedType}\footnote{
    An \cppinline{elaboratedType} refers to a type that potentially has a qualifier in ahead of it.
}.
The \cppinline{elaboratedType} must be equal to the enum type, which is accomplished through the \cppinline{namesType} matcher.
However, the ``enumDecl'' tag refers to a \cppinline{Decl} instead of a \cppinline{Type}, so \cppinline{hasDeclaration} is used to refer to the \cppinline{Decl} of the \cppinline{elaboratedType}. At last it is specified that the \cppinline{Decl} of must be equivalent to the node bound by ``enumDecl''.

The combined matcher satisfying the steps defined at the start of \cref{subsec:085tool:enum_node_matching_sin} was now been complete.
It should be clear to the reader that writing a single matcher that matches on all the necessary nodes of the enum-to-string tool was no trivial achievement.

\subsubsection*{Finding the namespace in code}
When developing the single step enum-to-string tool, the initial solution also consisted of potentially binding the namespace of the \cppinline{parmVarDecl}, as it was thought to be needed during node data processing.

Related to discussion in 6.3.3

\subsection{Node data processing}

\subsection{Handling the results}
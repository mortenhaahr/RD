\section{Build environment}

The documentation for writing applications using LibTooling such as \cite{MatchingClangAST, ClangTransformerTutorial} mainly concerns writing tools as part of the LLVM project repository. While this is good for contributing to the project, it is not ideal for version control and developing stand-alone projects.
It was necessary to create a build environment that allowed for out-of-tree builds that utilize LibTooling. A similar attempt was made in \cite{kasmisClangOutoftreeBuild2023} but the project has been abandoned since 2020 and LLVM has since moved from a distributed repository architecture to a monolithic repository architecture, so most of \cite{kasmisClangOutoftreeBuild2023} was obsolete.
The following section is dedicated to describing the important decisions made related to the build environment.

\subsection{General build settings}

Initially, some general settings for the project are configured which can be seen in \cref{code:080dev:cmake_base_settings}.
Line 1 forces Clang as the compiler which is highly recommended as LibTooling was compiled with Clang. Choosing another compiler may result in parts of the project being compiled with another standard library implementation, e.g., libstd++ that is the default for GCC. This may cause incompatibility between the application binary interfaces (ABIs) which is considered undefined behaviour, essentially leaving the entire program behaviour unspecified \cite{cppreferenceUndefinedBehaviorCppreference}. This concept is also known as ABI breakage.
Line 2 makes CMake generate the file ``compile\_commands.json'' during configuration and contains information related to which compilation command should be invoked on which source file. 
The file is used by LibTooling as it is needed in order to generate the AST across several compilation units in order to determine their relations \cite{JSONCompilationDatabase}. It should be enabled in all the CMake projects that should allow for Clang AST analysis.
Line 3 defines the C++ standard version, which is set to C++17 since LibTooling was compiled with this.
Line 4 defines the output directory of the executable to be in \textinline{<build_folder>/bin} which has importance concerning how LibTooling searches for include directories at run-time as described in \cref{subsec:080dev:rt_include}.
Finally, line 5 disables Run-Time Type Information (RTTI). RTTI allows the program to identify the type of an object at runtime, among others, by enabling the usage of the functions \cppinline{dynamic_cast} and \cppinline{typeid}. Since LLVM leaves it to the user whether RTTI should be used or not, it will attempt to use an implementation with RTTI if it is not explicitly disabled resulting in a nasty linker error when the implementation has not been compiled.

\begin{listing}[H]
    \begin{cmakecode}
set(CMAKE_CXX_COMPILER clang++)
set(CMAKE_EXPORT_COMPILE_COMMANDS 1)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin")
add_compile_options(-fno-rtti)
    \end{cmakecode}
    \caption{General settings for the CMake build environment.}
    \label{code:080dev:cmake_base_settings}
\end{listing}

\subsection{Linking against libraries}

%TODO: Write this subsec

\begin{listing}[H]
    \begin{cmakecode}
find_package(LLVM REQUIRED CONFIG)
find_package(Clang REQUIRED CONFIG)
message(STATUS "Found LLVM ${LLVM_PACKAGE_VERSION}")
message(STATUS "Using LLVMConfig.cmake in: ${LLVM_DIR}")

include_directories(${LLVM_INCLUDE_DIRS})
separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS})
add_definitions(${LLVM_DEFINITIONS_LIST})

add_executable(transformer transformation_base_project.cpp)

target_link_libraries(transformer
    clangAST
    clangASTMatchers
    clangBasic
    clangFrontend
    clangSerialization
    clangTooling
    clangTransformer
)
    \end{cmakecode}
    \caption{CMake code for linking against Clang libraries and adding the headers.}
    \label{code:080dev:cmake_link_libraries}
\end{listing}


\subsection{Run-time include directories}\label{subsec:080dev:rt_include}
When executing binaries created with LibTooling, a big part of the process consists of analyzing the source-code that is to be analyzed, which is done following the pipeline as shown in \cref{fig:030bac:llvmToolchainOverview}.
Most projects written in C++ makes use of the C++ standard library that implements many commonly used functionalities in C++. Naturally, these definitions would also have to be specified to the tool in order to be analyzed, however, it would be tedious for the user to specify manually on every tool invocation.
For practical reasons, LibTooling provides a mechanism for automatic discovery of header files that should be included when parsing source files. It finds the headers by using the relative path that the binary is being executed from by searching for a parent-directory with the pattern \textinline{lib/clang/<std_version>/include}, where \textinline{<std_version>} indicates which version of the standard library Clang was compiled with (in this project it was 17).
This hard-coded approach is quite simple but limited, as it forces the users to only run the tool in a directory where the headers can be found in the relative directory \textinline{<cwd>/../lib/clang/17/include}.
If the user attempts to run it somewhere else, and the analyzed files make use of standard library features, they will get an error while parsing the files (e.g. that the header \textinline{<stddef.h>} was not found).

Since tools written with LibTooling are invoking the parser of Clang, it is also possible to forward the include directory to as an argument to the compiler e.g. by specifying \textinline{-- -I"/usr/local/lib/clang/17"}.
However, this was found to be impractical since the location of the include path may vary depending on the system and since forgetting to write the include path results in some errors that can be very difficult to decipher. This means that if the tool was to be used by people other than the authors, it could provide unnecessary complexity.

Instead we ... CMake...

%TODO: Finish writing this


% Describe default search path is parents from build
% NOTE: ./transformer ../../input_file.cpp -- -I"/usr/local/lib/clang/17/include/" works for finding stdlib but is specific to the user
% Solution where providing a stdlib as should be explored using llvm::cl (I think)
\section{Tool structure} \label{sec:080dev:tool_structure}

Through inspection of existing LibTooling tools, such as \cite{llvmExternalClangExamples} and \cite{llvmLLVMCompilerInfrastructure2023}, and the development of tools for the R\&D project, a common structure for LibTooling tools has been identified. The structure can be used as a way of categorizing the different parts of such tools and can be seen below.

\begin{itemize}
    \item Command line parsing
    \item AST node matching
    \item Node data processing
    \item Handling the results
\end{itemize}

The \textbf{Command line parsing} part of the tool structure is responsible for the parsing of the command line options which the tool was invoked with and setting the configuration data that specifies the behaviour of the tool. A detailed description of this section of the tool structure can be found in \cref{subsec:080dev:CMDLineParsing}.

The \textbf{AST node matching} part of the tool structure is where the AST node matchers are defined and certain nodes of interest are bound to identifiers. AST node matchers traverse the AST of the source code passed to the tool through the command line and binds relevant nodes to identifiers which can be used in the Node data processing section. For a detailed description of the AST matching step, see \cref{subsec:080dev:ASTNodeMatching}.

The \textbf{Node data processing} part of the tool structure is where information is extracted from the nodes that were bound during the AST node matching step. This is where the primary functionality of the tool is implemented. There are multiple interfaces which can be used to extract information from bound nodes and they are described in \cref{subsec:080dev:NodeDataProcessing}.

The \textbf{Handling the results} part of the tool structure is where the matching and processing, defined in the previous parts, is applied. This is also where the results are handled and presented to the invoker of the tool. This part of the tool structure is described further in \cref{subsec:080dev:HandlingToolResults}.


\subsection{Command line parsing} \label{subsec:080dev:CMDLineParsing}

A good way of configuring the behaviour of a tool is through command line arguments. All LibTooling tools come with some common options which are always present, e.g., the option to parse a list of source files.

The way to add command line options to a tool is through the command line library provided by LLVM. This library makes it very easy to add new commands and provide help text for the options. A great example of how to use the library can be found in the implementation of ClangFormat \cite{llvmClangFormatClangFormat2023}, where they have multiple options with different types and default values.

\subsection{Matching the AST} \label{subsec:080dev:ASTNodeMatching}

The next step in working with LibTooling is to find the AST that is relevant for the tool through matching and binding. This is a very important part of the tool development as it defines what kind of information is available for the later stages of the tool. If the wrong AST is matched or the wrong nodes are bound, the later processing can become unnecessarily complex and complicated. Furthermore, the task of matching the AST can also be very difficult as there are currently more than 700 different matchers available as part of the library \cite{llvmASTMatcherReference}. 

A proposed way of matching the AST is by writing or finding a very simple example of the code that should be matched upon. The entire AST for that file can be printed through Clang by invoking:\\ \bashinline{clang -cc1 -ast-dump input_file}. 
This command will print all the AST information in the input file to the console, which can then be analyzed manually for the wanted nodes/patterns.

When an AST node has been identified as interesting to the tool it should be matched, which is typically done by using the predefined matchers of LibTooling \cite{llvmASTMatcherReference}.
It is also possible to write custom matchers, which can be very powerful when the standard matchers are lacking. An example of such could be if one wishes to recursively traverse the declaration context, which was the case in one of the implementations of the enum tool.
However, most the time the builtin matchers will be sufficient and they should therefore be the initial place to look when matching the AST.

%TODO: write about custom matchers
LibTooling defines three different basic categories of ``Matchers'' available to the users: Node Matchers, Narrowing Matchers and Traversal Matchers.
The Node Matchers are the most general matchers and matches specific types of AST Nodes, e.g., \cppinline{enumDecl} and \cppinline{constantArrayType}. A subset of the Node Matchers are also bindable, meaning that they can be bound to an identifier and processed in the later stages of the tool.
The Narrowing Matchers can be used to filter nodes that fulfil certain requirements, e.g. \cppinline{hasName} and \cppinline{isClass}. It also contains logical expressions such as \cppinline{allOf},\cppinline{anyOf} and \cppinline{unless}.
The Traversal Matchers can be used to traverse the node with its parents or children and thereby specify and bind to certain relations of subnodes. Examples of Traversal Matchers are \cppinline{hasDescendant}, \cppinline{specifiesType} \cite{llvmASTMatcherReference}.

When composing a matcher, i.e., combining several matchers, one typically starts by identifying the overall node type that wishes to be matched. This will be the outermost Node Matcher and in most cases, this should be bound.
A combination of narrowing matchers and traversal matchers can then be used to filter the matches depending on the information the tool needs.
In many scenarios, it may also be necessary to bind child nodes in order to get all the needed information.

Putting it all together, one could write a matcher that matches function declarations that are named ``f'' and that takes at least one parameter. Furthermore, the function declaration and parameter declaration could be bound to the identifiers ``function'' and ``parameter''.
This can be achieved using a combination of the three categories of matchers with the statement:\\ \cppinline{functionDecl(hasName("f"), hasParameter(0, parmVarDecl().bind("parmBind"))).bind("funcBind")}\\
In the example the matchers \cppinline{functionDecl} and \cppinline{parmVarDecl} are Node Matchers, \cppinline{hasName} is a Narrowing Matcher and \cppinline{hasParameter}\footnote{The 0 provided in \cppinline{hasParameter} indicates that it must match the first argument of the function.} is a Traversal Matcher.

The composition of matchers is typically done iteratively where one starts by matching a superset of nodes which are iteratively narrowed down until the tool is left with the nodes that contain the needed information. 

\subsection{Node data processing} \label{subsec:080dev:NodeDataProcessing}

When the nodes have been matched and bound, the information stored inside of them must be extracted. The way to do so is by using an object that inherits from \cppinline{MatchFinder::MatchCallback}.
The \\\cppinline{MatchFinder::MatchCallback} class defines the \cppinline{run} method which must be overridden by its children. The run method has a \cppinline{const MatchFinder::MatchResult &Result} parameter which contains the bound nodes of the match (e.g. ``funcBind'' and ``parmBind'' in the example provided earlier).
The information inside the nodes can then be extracted and used e.g., for source code generation, diagnostic messages or other information relevant to the tool.

The \cppinline{MatchFinder::MatchCallback} is the raw interface which allows for node processing but it lacks many convenience methods and requires the user to save the extracted information explicitly. The Clang developers have created an abstraction over the \cppinline{MatchFinder::MatchCallback} with convenience methods and an automatic way of extracting information. This interface also allows for easy conversion to source code changes. The abstraction is called \cppinline{Transformer} and is what will be used in this R\&D project.

Transformers combine a rewriting rule with a result consumer. Rewriting rules combine a matcher with an AST edit and potential metadata. The AST edit is a change in the source code comprised of a source code location to rewrite and a concatenation of multiple Stencils which generate the new source text. Stencils extract information from bound nodes and convert the information to strings. A more detailed description of Stencils can be seen in \cref{subsubsec:080dev:stencils}.

The result consumer is responsible for saving the relevant results so they can be processed by the \cppinline{ClangTool} later. The result consumer is further described in \cref{subsubsec:080dev:Consumers}.

\subsubsection*{Stencils} \label{subsubsec:080dev:stencils}

The \href{https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/Stencil.h}{stencil interface} is used to extract information from bound nodes and convert the information to strings.  The stencil interface is an abstraction on top of \cppinline{MatchComputation<std::string>} which is called on matched nodes through the Transformer API. 

Examples of use-cases for the stencil interface could be to extract the element type of an array or to issue a warning at a given location. The functions of the predefined stencils are primarily focused on control flow, concatenation of stencils and expression handling. Therefore it is very likely that the creator of a tool will have to create custom stencils to extract the necessary data from the bound nodes.

Luckily the stencil interface allows the simple conversion from \cppinline{MatchConsumer<std::string>} to a \cppinline{Stencil} through the \cppinline{run} method. The \cppinline{MatchConsumer<T>} type is a typename for \\ \cppinline{std::function<Expected<T>>(const ast_matchers::MatchFinder::MatchResult &)} with \cppinline{std::string} as the template parameter. This API allows the creator of a tool to write small methods that extract the necessary information from a bound node as a string and seamlessly concatenate them together through the \cppinline{cat} stencil.

All the predefined stencils return strings but it is possible to create an similar library that returns any type of data if that is required for the tool. The reason the predefined stencils work solely with strings is that it is primarily used to generate source code changes which must be converted to strings of some sort in order to be written to disk. 

Similarly to the stencil interface, LibTooling also defines the \href{https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RangeSelector.h}{range selector interface}.
This interface also builds upon \cppinline{MatchConsumer<T>} but with \cppinline{CharSourceRange} as an output instead of strings. A \cppinline{CharSourceRange} refers to a range of characters defined at a specific location of the provided source files. It thereby allows the tool implementor to add or modify source code exactly where they want it.

\subsubsection*{Combining matchers and stencils}

It should be clear by now that in order to create tools, it is necessary to have both matchers and stencils. Within this lies some interesting design decisions of how the matchers and stencils should be used in conjunction.

In general, there are two approaches to take when using matchers and stencils in conjunction.\\
The first approach is to create a simple matcher that binds only to the outermost node and then create detailed stencils that extract the information based on the single binding.\\
The second approach is to create a detailed matcher that binds to multiple nodes and then create simple stencils that utilize the many bindings.\\
Both approaches can be used to implement the same functionality but the implementations look vastly different.
 
If the implementor chooses the first approach, then the stencils can easily become complicated because one must filter and extract information from a single node.

If the second approach is chosen, the responsibility of extracting information from the nodes is placed inside the composed matcher. This can lead to some very complex matchers that can be difficult to understand. However, the stencils that extract information from the bound nodes will be much simpler.\\
Furthermore, when following this approach one can easily fall into the pitfall of trying to match too much data that is not required at the end.\\
E.g., when developing the enum tool it was attempted to bind the namespace of the parameter of an existing \cppinline{to_string} function since it was thought to be needed when writing the transformation. In the end, the binding was unnecessary as the namespace could easily be extracted through a stencil and the namespace binding itself did not provide enough context.
However, a significant amount of time was spent on writing an exact matcher that could recursively traverse the namespace qualifiers of a parameter and bind it.

Ultimately, the best approach to follow depends upon the specific scenario. In some cases, it may be better to write detailed stencils and in other cases detailed matchers. The important thing is to not tunnel-vision too heavily on a single approach and keep an open mind towards the other. Perhaps the best approach lies within a mixture of the two.

\subsubsection*{Consuming the transformation changes} \label{subsubsec:080dev:Consumers}

When the bound nodes have been processed through the Transformer API, the transformation changes should be consumed. This is done through a \cppinline{Consumer} which is a type alias of a \cppinline{std::function} which takes \cppinline{Expected<TransformerResult<T>>} as a parameter. The \cppinline{TranformerResult<T>} type contains any source code changes that were generated by the rule and the provided metadata with type T.

The consumer can make decisions based on the received edits and metadata, but the most common use case for the consumer is to have it store the metadata and changes to external variables so it can be later used for further processing.

\subsection{Handling the results} \label{subsec:080dev:HandlingToolResults}
When the rules and transformers have been specified it is time to run them on the source code, which is done through a \cppinline{ClangTool}. \cppinline{ClangTool} is the API that runs the match finders over all the specified source code.
All tools made with clang need to use \cppinline{ClangTool} to tie it all together.\\
The \cppinline{ClangTool} class has a \cppinline{run} method which takes a \cppinline{FrontendAction} and runs it on the specified source code.
This can be considered the method that executes the tool.

The \cppinline{ClangTool} class can be extended to handle the results from the Transformer in different ways. A tool which runs a Transformer could, for example, save the source code changes to disk or present the changes to the caller of the tool and have them choose if the changes should be made. The extended \cppinline{ClangTool} also often contains the variables which will be updated in the node processing step.
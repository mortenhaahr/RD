\pagebreak
\section{Enum to string tool}
This section describes a tool that is capable of generating \cppinline{std::string_view to_string(EnumType e)} functions for each enum declaration defined in a C++ program. The \cppinline{to_string} functions take an instance of the enum as argument and returns a string corresponding to the name of the enumerator.

An example of the outputs of running the tool can be seen in \cref{code:085tool:example_enum}. In the example, at part (1), the enum \cppinline{Animal} is declared with two enumerators: Dog and Cat. In part (2), the \cppinline{to_string} function that would be generated by the tool can be seen. Part (3) and (4) shows another enum declaration with another generated \cppinline{to_string} function.

\begin{listing}[H]
    \begin{cppcode}
// (1): Example enum declaration:
enum class Animal{
    Dog, // Dog is an example of an enumerator (aka. enum constant)
    Cat // Cat is another example of an enumerator
};


// (2): Function that the tool generates:
constexpr std::string_view to_string(Animal e){
    switch(e) {
        case Animal::Dog: return "Dog";
        case Animal::Cat: return "Cat";
    }
}

// (3): Another enum declaration:
enum Greetings {
    ... // enumerators for Greetings
};

// (4): The other enum declaration also gets a to_string function
constexpr std::string_view to_string(Greetings e){
    switch (e) {
        ... 
    }
}
    \end{cppcode}
    \caption{Example (1) declaring an enum in C++ and (2) the \cppinline{to_string} function that the tool generates. In (3) another enum was declared from which another \cppinline{to_string} function is generated (4).}
    \label{code:085tool:example_enum}
\end{listing}

The tool differentiates itself from the previous examples by being a generative tool, meaning that it inserts source-code into a file.
In contrast, the renaming tool and CStyle comparison tool were refactoring tools that would overwrite existing code-lines.
While the difference may seem subtle, it can be more challenging to design generative tools, as there are stricter requirements related to analyzing if the generated code is syntactically correct when combined with the existing code-base.\\
E.g., with the enum to string tool it is necessary to determine if there already exists a function named \cppinline{to_string} in the same namespace that takes a single parameter of the enum type, since redefinition of functions is not allowed in C++.
In case such a function already exists, one needs to determine a strategy on how to handle the conflicts, e.g., by leaving the function untouched or overwriting it.
The act of determining whether such a function exists can be quite complex, as one must analyze the compilation-unit for its existence.

Likewise, there are typically extra semantic considerations to be made when designing a generative tool. E.g., if \cppinline{std::string_view to_string(Animal e)} function exists in a namespace ``A'' and \cppinline{Animal} was declared in namespace ``B'', then it would be syntactically correct to add the \cppinline{to_string} function to namespace ``B''. The question of whether it semantically makes sense for these functions to coexist arises
\footnote{This must be determined on a case-by-case basis. E.g. it might make sense for two \cppinline{print(X)} functions to exist in seperate namespaces. One that is part of the public API and one that is intended for debugging. However, it might not make sense for two \cppinline{release(X)} functions to exist in seperate namespaces as this would indicate there are several ways of releasing the ressources allocated in X. (And yet in other cases it might make perfect sense for two \cppinline{release(X)} functions to exist.)}
and one needs to select a strategy for handling such scenarios.\\
Examples of such strategies could be to ignore the cases, warn the user about them, delete the non-generated version or overwriting the non-generated version.\\
It can be difficult to find and consider all the possible semantic strategies when developing a tool. For some problems there could be infinite ways to generate the wanted behaviour, like there is when creating a program through a programming language. Some of the posibilities may be better than others but there is still a large design space that could be explored.
To demonstrate this, a list of scenarios where one might need to consider the behaviour for the enum to string tool can be seen below. The examples in the list increasingly become more abstract and difficult to implement.

\begin{itemize}
    \vspace{-0.75em}
    \item A \cppinline{to_string} function taking multiple arguments already exists.
    \item The enum is declared privately inside a class.
    \item The enum is declared inside an anonymous namespace.
    \item The enum is declared inside a namespace that by convention is intended to be ignored by users (e.g., \cppinline{detail}, \cppinline{implementation}, etc.).
    \item A function that implements the same behaviour as the generated \cppinline{to_string} function exists.
    \item A function that implements a similar behaviour as the generated \cppinline{to_string} function exists.
    \item A similarly named function exists that implements a similar behaviour as the generated \cppinline{to_string} function exists.
    \item ...
\end{itemize}

For the enum to string tool, it was decided to overwrite syntactically conflicting implementations of the \cppinline{to_string()} functions.
This has the benefit of allowing the user to change the enum and re-run the tool to see the updated changes. E.g., in \cref{code:085tool:example_enum} if a \cppinline{Animal::Horse} was added to the enum declaration, re-running the tool would update the corresponding \cppinline{std::string_view to_string(Animal e)} function.
However, it also has the downside of essentially reserving the \cppinline{to_string} name leaving the user unable to write their own versions of the function.\\
Furthermore, it was decided to also implement the semantic rule that if a \cppinline{to_string} function already exists in a different namespace, then the existing version must be overwritten. This was mainly decided as there are some interesting challenges to consider in relation to recursively traversing the namespaces, which are described in \cref{subsec:085tool:enum_node_matching}.

\subsection{Command line parsing}

\subsection{AST node matching}\label{subsec:085tool:enum_node_matching}
% recursively traversing namespaces